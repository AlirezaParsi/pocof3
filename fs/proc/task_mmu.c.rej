static void
show_map_vma(struct seq_file *m, struct vm_area_struct *vma)
{
	struct mm_struct *mm = vma->vm_mm;
	struct file *file = vma->vm_file;
	vm_flags_t flags = vma->vm_flags;
	unsigned long ino = 0;
	unsigned long long pgoff = 0;
	unsigned long start, end;
	dev_t dev = 0;
	const char *name = NULL;
	struct dentry *dentry;

	if (file) {
		struct inode *inode = file_inode(vma->vm_file);
#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
		if (unlikely(inode->i_state & INODE_STATE_SUS_KSTAT)) {
			susfs_sus_ino_for_show_map_vma(inode->i_ino, &dev, &ino);
			goto bypass_orig_flow;
		}
#endif
		dev = inode->i_sb->s_dev;
		ino = inode->i_ino;
#ifdef CONFIG_KSU_SUSFS_SUS_KSTAT
bypass_orig_flow:
#endif
		pgoff = ((loff_t)vma->vm_pgoff) << PAGE_SHIFT;
		dentry = file->f_path.dentry;
        if (dentry) {
        	const char *path = (const char *)dentry->d_name.name; 
            if (strstr(path, "lineage")) {
			start = vma->vm_start;
			end = vma->vm_end;
			show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);
			name = "/system/framework/framework-res.apk";
			goto done;
            }
			if (strstr(path, "jit-zygote-cache")) { 
			start = vma->vm_start;
			end = vma->vm_end;
			show_vma_header_prefix_fake(m, start, end, flags, pgoff, dev, ino);
			goto bypass;
            }
        }
	}

	start = vma->vm_start;
	end = vma->vm_end;
	if (show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino))
		return;

	bypass:
	/*
	 * Print the dentry name for named mappings, and a
	 * special [heap] marker for the heap:
	 */
	if (file) {
		char *buf;
		size_t size = seq_get_buf(m, &buf);

		/*
		 * This won't escape newline characters from the path. If a
		 * program uses newlines in its paths then it can kick rocks.
		 */
		if (size > 1) {
			char *p;

			p = d_path(&file->f_path, buf, size);
			if (!IS_ERR(p)) {
				size_t len;

				/* Minus one to exclude the NUL character */
				len = size - (p - buf) - 1;
				if (likely(p > buf))
					memmove(buf, p, len);
				buf[len] = '\n';
				seq_commit(m, len + 1);
				return;
			}
		}

		/* Set the overflow status to get more memory */
		seq_commit(m, -1);
		return;
	}

	if (vma->vm_ops && vma->vm_ops->name) {
		name = vma->vm_ops->name(vma);
		if (name)
			goto done;
	}

	name = arch_vma_name(vma);
	if (!name) {
		if (!mm) {
			seq_write(m, "[vdso]\n", 7);
			return;
		}

		if (vma->vm_start <= mm->brk &&
		    vma->vm_end >= mm->start_brk) {
			seq_write(m, "[heap]\n", 7);
			return;
		}

		if (is_stack(vma)) {
			seq_write(m, "[stack]\n", 8);
			return;
		}

		if (vma_get_anon_name(vma)) {
			seq_print_vma_name(m, vma);
			return;
		}
	}

done:
	if (name)
		seq_puts(m, name);
	seq_putc(m, '\n');
}

static int show_map(struct seq_file *m, void *v)
{
	show_map_vma(m, v);
	m_cache_vma(m, v);
	return 0;
}